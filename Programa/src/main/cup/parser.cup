/* 
 * Analizador Sintáctico con Análisis Semántico Integrado + Código Intermedio
 * --------------------------------------------------------------------------
 * 
 * CAMBIOS PARA PROYECTO 2:
 * - Manejo de scopes y tabla de símbolos semántica
 * - Verificación de tipos y compatibilidad
 * - Detección de errores semánticos
 * 
 */

/* Imports y paquetes */
import java_cup.runtime.*;
import java.util.*;
import main.java.symbol.SymbolTable;
import main.java.symbol.SemanticSymbolTable;
import main.java.symbol.SymbolInfo;
import main.java.intermedio.IntermediateCodeGenerator;

/* Código de usuario */
parser code {:

    private SemanticSymbolTable semanticTable;
    
    private SymbolTable symbolTable;
    
    private int errorCount = 0;

    private Stack<String> scopeContext = new Stack<>();
    
    private String currentFunctionName = null;

    private Map<String, String> codeValues  = new HashMap<>();

    private int uniqueCounter  = 0;
    
    private IntermediateCodeGenerator codeGenerator;

    private boolean codeGenerationEnabled = false;

    private int labelCounter = 0;

    private Stack<String> labelStack = new Stack<>();
    private Stack<String[]> labelPairStack = new Stack<>();
    private Stack<String[]> loopLabelStack = new Stack<>();

    private boolean inSwitchContext = false;
    private List<String> deferredSwitchCode = new ArrayList<>();
    
    public void enableCodeGeneration(String outputFile) {
        this.codeGenerator = new IntermediateCodeGenerator(outputFile);
        this.codeGenerationEnabled = true;
        System.out.println("Generación de código intermedio habilitada");
    }
    
    public void disableCodeGeneration() {
        this.codeGenerationEnabled = false;
        this.codeGenerator = null;
    }
    
    public IntermediateCodeGenerator getCodeGenerator() {
        return codeGenerator;
    }

    public void initTables() {
        semanticTable = new SemanticSymbolTable();
        symbolTable = semanticTable.getOriginalTable();
        System.out.println("Iniciando analisis semantico...");
        
        scopeContext.push("GLOBAL");
    }
    
    public void setSymbolTable(SymbolTable symbolTable) {
        this.symbolTable = symbolTable;
        if (semanticTable == null) {
            initTables();
        }
    }
    
    public SemanticSymbolTable getSemanticTable() {
        if (semanticTable == null) {
            initTables();
        }
        return semanticTable;
    }

    public String getCurrentFunctionName() {
        return currentFunctionName;
    }
    
    public void setCurrentFunctionName(String functionName) {
        this.currentFunctionName = functionName;
    }

    public void enterFunctionScope(String functionName, String returnType) {
        if (semanticTable != null) {
            semanticTable.enterScope("FUNCTION", functionName);
            scopeContext.push("FUNCTION:" + functionName);
            setCurrentFunctionName(functionName); 
            System.out.println("Entrando a función: " + functionName);
        }
    }
    
    public void exitFunctionScope() {
        if (semanticTable != null && !scopeContext.isEmpty()) {
            String context = scopeContext.pop();
            semanticTable.exitScope();
            setCurrentFunctionName(null);
            System.out.println("Saliendo de scope: " + context);
        }
    }
    
    public void enterBlockScope() {
        if (semanticTable != null) {
            semanticTable.enterScope("BLOCK", "block");
            scopeContext.push("BLOCK");
            System.out.println("Entrando a bloque...");
        }
    }
    
    public void exitBlockScope() {
        if (semanticTable != null && !scopeContext.isEmpty()) {
            String context = scopeContext.pop();
            semanticTable.exitScope();
            System.out.println("Saliendo de bloque...");
        }
    }
    
    public void enterControlScope(String controlType) {
        if (semanticTable != null) {
            semanticTable.enterScope(controlType.toUpperCase(), controlType.toLowerCase() + "_block");
            scopeContext.push(controlType.toUpperCase());
            System.out.println("Entrando a " + controlType + "...");
        }
    }
    
    public void exitControlScope() {
        if (semanticTable != null && !scopeContext.isEmpty()) {
            String context = scopeContext.pop();
            semanticTable.exitScope();
            System.out.println("Saliendo de control: " + context);
        }
    }
    
    public void finalizeSemantic() {
        if (semanticTable != null) {
            boolean hasMain = semanticTable.checkMainFunction();
            if (!hasMain) {
                errorCount++;
            }
            
            semanticTable.printSummary();
            
            try {
                semanticTable.escribirTablas("semantic_analysis.txt");
                System.out.println("Analisis semantico completado. Ver: semantic_analysis.txt");
            } catch (Exception e) {
                System.err.println("Error escribiendo archivo semantico: " + e.getMessage());
            }
        }
        
        if (codeGenerationEnabled && codeGenerator != null) {
            codeGenerator.printCode();
            codeGenerator.printStatistics();
            codeGenerator.writeToFile();
        }
    }
    
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintactico #" + errorCount + " en linea " + (s.left + 1) + 
                          ", columna " + (s.right + 1) + ": Token inesperado '" + s.value + "'");
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        errorCount++;
        System.err.println("Error sintactico fatal #" + errorCount + " en linea " + (s.left + 1) + 
                          ", columna " + (s.right + 1) + ": No se pudo recuperar del error");
        
        System.err.println("Total de errores encontrados: " + errorCount);
        
        finalizeSemantic();
    }
    
    public void report_error(String message, Object info) {
        errorCount++;
        if (info instanceof Symbol) {
            Symbol s = (Symbol) info;
            System.err.println("Error de recuperacion #" + errorCount + " en linea " + (s.left + 1) + 
                              ", columna " + (s.right + 1) + ": " + message);
        } else {
            System.err.println("Error de recuperacion #" + errorCount + ": " + message);
        }
    }
    
    public int getErrorCount() {
        return errorCount + (semanticTable != null ? semanticTable.getErrorCount() : 0);
    }
    
    public void updateVariableType(String id, String type) {
        if (symbolTable != null) {
            symbolTable.actualizarTipoVariable(id, type);
        }
    }
    
    public void markAsFunction(String id, String returnType) {
        if (symbolTable != null) {
            symbolTable.marcarComoFuncion(id, returnType);
        }
    }

    public String saveCodeValue(String semanticType, String codeValue) {
        if (codeGenerationEnabled && codeValue != null) {
            String uniqueKey = "expr_" + (++uniqueCounter);
            codeValues.put(uniqueKey, codeValue);
            System.out.println("DEBUG: Guardando " + uniqueKey + " = " + codeValue + " (tipo: " + semanticType + ")");
            return uniqueKey; 
        }
        return null;
    }

    public String getCodeValue(String key) {
        if (key != null && key.startsWith("expr_")) {
            String value = codeValues.get(key);
            System.out.println("DEBUG: Recuperando " + key + " = " + value);
            return value != null ? value : key;
        }
        return key;
    }

    private Stack<String> codeKeyStack = new Stack<>();
    
    public void pushCodeKey(String key) {
        if (codeGenerationEnabled && key != null) {
            codeKeyStack.push(key);
        }
    }
    
    public String popCodeKey() {
        if (codeGenerationEnabled && !codeKeyStack.isEmpty()) {
            return codeKeyStack.pop();
        }
        return null;
    }

    public String generateLabel() {
        return "L" + (++labelCounter);
    }

    public void pushLabel(String label) {
        labelStack.push(label);
    }

    public String popLabel() {
        return labelStack.isEmpty() ? null : labelStack.pop();
    }

    public void pushLabelPair(String label1, String label2) {
        labelPairStack.push(new String[]{label1, label2});
    }

    public String[] popLabelPair() {
        return labelPairStack.isEmpty() ? null : labelPairStack.pop();
    }

    public String[] peekLabelPair() {
        return labelPairStack.isEmpty() ? null : labelPairStack.peek();
    }

    public void enterSwitchContext() {
        inSwitchContext = true;
        deferredSwitchCode.clear();
        System.out.println("DEBUG: Entrando a contexto SWITCH - código diferido");
    }
    
    public void exitSwitchContext() {
        inSwitchContext = false;
        System.out.println("DEBUG: Saliendo de contexto SWITCH");
    }
    
    public boolean isInSwitchContext() {
        return inSwitchContext;
    }
    
    public void deferSwitchCode(String code) {
        if (inSwitchContext) {
            deferredSwitchCode.add(code);
            System.out.println("DEBUG: Código diferido para switch: " + code);
        }
    }
    
    public List<String> getDeferredSwitchCode() {
        return new ArrayList<>(deferredSwitchCode);
    }

    public void pushLoopLabels(String startLabel, String endLabel) {
        loopLabelStack.push(new String[]{startLabel, endLabel});
        System.out.println("DEBUG: Loop labels pushed - start: " + startLabel + ", end: " + endLabel);
    }
    
    public String[] popLoopLabels() {
        if (!loopLabelStack.isEmpty()) {
            String[] labels = loopLabelStack.pop();
            System.out.println("DEBUG: Loop labels popped - start: " + labels[0] + ", end: " + labels[1]);
            return labels;
        }
        return null;
    }
    
    public String[] peekLoopLabels() {
        return loopLabelStack.isEmpty() ? null : loopLabelStack.peek();
    }
:}

/* Declaración de terminales */
terminal IF, ELIF, ELSE, DO, WHILE, FOR, BREAK, CONTINUE, RETURN;
terminal INT, FLOAT, BOOL, CHAR, STRING, VOID;
terminal READ, WRITE, MAIN, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, POW;
terminal INCREMENT, DECREMENT;
terminal LT, LTE, GT, GTE, EQ, NEQ;
terminal AND, OR, NOT;
terminal LPAREN, RPAREN, LBLOCK, RBLOCK;
terminal QUESTION, COMMA, ASSIGN;
terminal LBRACKET, RBRACKET;
terminal ID, LIT_INT, LIT_FLOAT, LIT_BOOL, LIT_CHAR, LIT_STRING;
terminal SWITCH, CASE, DEFAULT, COLON;

/* Declaración de no terminales */
non terminal program;
non terminal block;
non terminal decl_var, decl_fun, decl_arr;
non terminal stmt;
non terminal assign;
non terminal array_assign;
non terminal String exp;              
non terminal String exp_arit, term_arit, factor_arit, power_arit, atom_arit;
non terminal String exp_rel;          
non terminal String exp_log, term_log, factor_log;
non terminal String unary_exp;        
non terminal ctrl, if_stmt, do_while, for_stmt;
non terminal break_stmt, continue_stmt, return_stmt;
non terminal read_stmt, write_stmt;
non terminal String tipo, tipo_r;     
non terminal String arr_access;      
non terminal exp_list, exp_matrix, matrix_row;
non terminal param, param_list, arg_list;
non terminal String literal;         
non terminal String llamada_fun;     
non terminal switch_stmt, case_list, case_stmt, default_stmt;


/* Precedencia de operadores */
precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc LT, LTE, GT, GTE, EQ, NEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right POW;
precedence right INCREMENT, DECREMENT;
precedence left LPAREN, RPAREN, LBRACKET, RBRACKET;
precedence left ELSE;

/* 
 * Gramática con recuperación de errores y análisis semántico
 */
start with program;

/* 
 * Estructura del programa con manejo correcto de main
 */
program ::= VOID MAIN:m LPAREN RPAREN LBLOCK 
          {: 
             List<String> noParams = new ArrayList<String>();
             parser.getSemanticTable().declareFunction("main", "VOID", noParams, mleft, mright);
             
             parser.getSemanticTable().enterScope("FUNCTION", "main");
             parser.setCurrentFunctionName("main");
             System.out.println("Entrando a función main");
             
             if (parser.codeGenerationEnabled) {
                 parser.getCodeGenerator().startFunction("main", "VOID");
             }
          :}
          block RBLOCK
          {: 
             parser.getSemanticTable().exitScope();
             parser.setCurrentFunctionName(null);
             System.out.println("Saliendo de función main");
             
             if (parser.codeGenerationEnabled) {
                 parser.getCodeGenerator().endFunction("main");
             }
             
             parser.finalizeSemantic();
          :}
          | decl_fun:f program
          {: 
             if (f != null) {
                 System.out.println("Función declarada: " + f.toString());
             }
          :}
          | error program  
          {: 
             System.err.println("Error en la estructura del programa. Continuando análisis..."); 
          :}
          | /* programa vacío */
          ;

/* 
 * Declaración de funciones con análisis semántico y scope correcto
 */
decl_fun ::= tipo_r:t ID:id LPAREN 
            {: 
              parser.enterFunctionScope(id.toString(), t.toString());
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().startFunction(id.toString(), t.toString());
              }
              
              System.out.println("DEBUG: Iniciando función " + id + ", scope abierto para parámetros");
           :}
           param_list:params RPAREN 
           {: 
              List<String> paramTypes = new ArrayList<String>();
              if (params != null) {
                  paramTypes = (List<String>) params;
              }
              
              if (parser.getSemanticTable() != null) {
                  parser.getSemanticTable().declareFunction(id.toString(), t.toString(), paramTypes, idleft, idright);
                  System.out.println("DEBUG: Función '" + id + "' declarada con " + paramTypes.size() + " parámetros");
              }
              
              System.out.println("DEBUG: Parámetros procesados, entrando al cuerpo de función");
           :}
           LBLOCK block RBLOCK
           {: 
              System.out.println("DEBUG: Finalizando función completa");
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().endFunction();
              }
              
              parser.exitFunctionScope();
           :}
           | tipo_r:t ID:id LPAREN RPAREN 
           {: 
              parser.enterFunctionScope(id.toString(), t.toString());
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().startFunction(id.toString(), t.toString());
              }
              
              if (parser.getSemanticTable() != null) {
                  List<String> noParams = new ArrayList<String>();
                  parser.getSemanticTable().declareFunction(id.toString(), t.toString(), noParams, idleft, idright);
                  System.out.println("DEBUG: Función '" + id + "' sin parámetros declarada");
              }
           :}
           LBLOCK block RBLOCK
           {: 
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().endFunction();
              }
              
              parser.exitFunctionScope();
           :}
           ;

/* 
 * Tipos de retorno para funciones
 */
tipo_r ::= INT {: RESULT = "INT"; :}
         | FLOAT {: RESULT = "FLOAT"; :}
         | CHAR {: RESULT = "CHAR"; :}
         | BOOL {: RESULT = "BOOL"; :}
         | VOID {: RESULT = "VOID"; :}
         ;

/* 
 * Lista de parámetros de función
 */
param_list ::= param:p
             {: 
                List<String> paramList = new ArrayList<String>();
                if (p != null) {
                    paramList.add(p.toString());
                }
                RESULT = paramList;
             :}
             | param_list:list COMMA param:p
             {: 
                List<String> paramList = new ArrayList<String>();
                if (list != null) {
                    paramList = (List<String>) list;
                }
                if (p != null) {
                    paramList.add(p.toString());
                }
                RESULT = paramList;
             :}
             ;

/* 
 * Parámetro individual con análisis semántico
 */
param ::= tipo:t ID:id 
        {: 
           if (parser.getSemanticTable() != null) {
               parser.getSemanticTable().declareParameter(id.toString(), t.toString(), idleft);
               System.out.println("DEBUG: Parámetro '" + id + "' declarado como " + t);
           }
           
           if (parser.codeGenerationEnabled) {
               parser.getCodeGenerator().declareParameter(id.toString(), t.toString());
           }
           
           RESULT = t.toString();
        :}
        ;

/* 
 * Bloque de código
 */
block ::= stmt block
        | error block  {: System.err.println("Error en bloque de código. Continuando..."); :}
        | /* bloque vacío */
        ;

/* 
 * Tipos de datos
 */
tipo ::= INT {: RESULT = "INT"; :}
       | FLOAT {: RESULT = "FLOAT"; :}
       | BOOL {: RESULT = "BOOL"; :}
       | CHAR {: RESULT = "CHAR"; :}
       | STRING {: RESULT = "STRING"; :}
       ;

/* 
 * Declaración de arreglos con análisis semántico
 */
decl_arr ::= tipo:t ID:id LBRACKET exp:e1 RBRACKET LBRACKET exp:e2 RBRACKET QUESTION
           {: 
              String arrayType = t.toString() + "[][]";
              
              if (parser.getSemanticTable() != null) {
                  parser.getSemanticTable().declareVariable(id.toString(), arrayType, idleft, idright,true);
              }
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().declareVariable(id.toString(), arrayType);
              }
              
              parser.updateVariableType(id.toString(), arrayType);
           :}
           | tipo:t ID:id LBRACKET exp:e1 RBRACKET LBRACKET exp:e2 RBRACKET ASSIGN exp_matrix QUESTION
           {: 
              String arrayType = t.toString() + "[][]";
              
              if (parser.getSemanticTable() != null) {
                  parser.getSemanticTable().declareVariable(id.toString(), arrayType, idleft, idright);
              }
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().declareVariable(id.toString(), arrayType);
                  parser.getCodeGenerator().addComment("Array inicializado con matriz");
              }
              
              parser.updateVariableType(id.toString(), arrayType);
           :}
           ;

/* Estructura de matriz */
exp_matrix ::= LBRACKET matrix_row RBRACKET
             | LBRACKET matrix_row COMMA matrix_row RBRACKET
             ;

/* Fila de matriz */
matrix_row ::= LBRACKET exp_list RBRACKET;

/* Lista de expresiones */
exp_list ::= exp
           | exp COMMA exp_list
           ;

/* Acceso a arreglos con verificación semántica */
arr_access ::= ID:id LBRACKET exp:e1 RBRACKET LBRACKET exp:e2 RBRACKET
             {: 
                if (parser.getSemanticTable() != null) {
                    String resultType = parser.getSemanticTable().checkArrayAccess(
                        id.toString(), e1, e2, idleft
                    );
                    
                    if (resultType == null) {
                        RESULT = "ERROR";
                    } else {
                        RESULT = resultType; 
                    }                        
                } else {
                    RESULT = "ERROR";
                }

                if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                    String index2Key = parser.popCodeKey();
                    String index1Key = parser.popCodeKey();
                    String index2Code = parser.getCodeValue(index2Key);
                    String index1Code = parser.getCodeValue(index1Key);
                    
                    String tempVar = parser.getCodeGenerator().generateArrayAccess(id.toString(), index1Code, index2Code);
                    
                    String newKey = parser.saveCodeValue(RESULT, tempVar);
                    parser.pushCodeKey(newKey);
                    
                    System.out.println("DEBUG: Array access " + id + "[" + index1Code + "][" + index2Code + "] = " + tempVar);
                }
             :}
             ;

/* 
 * Sentencias con manejo semántico de bloques
 */
stmt ::= exp:e QUESTION
       {: 
          if (parser.getSemanticTable() != null && e != null) {
          }
       :}
       | assign
       | array_assign
       | decl_var
       | decl_arr
       | ctrl
       | break_stmt
       | continue_stmt
       | return_stmt
       | read_stmt
       | write_stmt
       | LBLOCK block RBLOCK
       {: 
          parser.enterBlockScope();
          parser.exitBlockScope();
       :}
       | error QUESTION  {: System.err.println("Error en sentencia. Recuperando en ';'..."); :}
       ;


// Nueva regla para asignación a arrays:
array_assign ::= ID:id LBRACKET exp:e1 RBRACKET LBRACKET exp:e2 RBRACKET ASSIGN exp:value QUESTION
               {: 
                  if (parser.getSemanticTable() != null) {
                      String arrayType = parser.getSemanticTable().checkArrayAccess(id.toString(), e1, e2, idleft);
                      
                      if (arrayType != null && !parser.getSemanticTable().checkTypeCompatibility(arrayType, value, idleft)) {
                          parser.report_error("Tipo incompatible en asignación a array", null);
                      }
                  }
                  
                  if (parser.codeGenerationEnabled) {
                      String valueKey = parser.popCodeKey();  
                      String index2Key = parser.popCodeKey(); 
                      String index1Key = parser.popCodeKey(); 
                      
                      String valueCode = parser.getCodeValue(valueKey);
                      String index2Code = parser.getCodeValue(index2Key);
                      String index1Code = parser.getCodeValue(index1Key);
                      
                      parser.getCodeGenerator().generateArrayAssignment(id.toString(), index1Code, index2Code, valueCode);
                      
                      System.out.println("DEBUG: Array assignment " + id + "[" + index1Code + "][" + index2Code + "] = " + valueCode);
                  }
               :}
               ;
/* 
 * Asignación con verificación de tipos 
 */
assign ::= ID:id ASSIGN exp:e QUESTION
         {:
            boolean valid = parser.getSemanticTable().checkAssignment(id.toString(), e, idleft);
            
            if (valid) {
                System.out.println("Asignacion valida: " + id + " = " + e);
                
                if (parser.codeGenerationEnabled && valid) {
                    String expKey = parser.popCodeKey();
                    String expCode = parser.getCodeValue(expKey);
                    
                    if (parser.isInSwitchContext()) {
                        parser.deferSwitchCode(id.toString() + " = " + expCode);
                        System.out.println("DEBUG: Asignación diferida para switch: " + id + " = " + expCode);
                    } else {
                        parser.getCodeGenerator().generateAssignment(id.toString(), expCode);
                        System.out.println("DEBUG: Asignación inmediata: " + id + " = " + expCode);
                    }
                }
            } else {
                System.err.println("Error en asignacion a variable: " + id);
            }
         :}
         ;

/* 
 * Declaración de variables con verificación semántica completa
 */
decl_var ::= tipo:t ID:id ASSIGN exp:e QUESTION
           {: 
              boolean declared = parser.getSemanticTable().declareVariable(id.toString(), t, idleft, idright, true);
              
              if (declared) {
                  if (e != null) {
                      boolean compatible = parser.getSemanticTable().checkTypeCompatibility(t, e, idleft);
                      if (compatible) {
                          System.out.println("Variable '" + id + "' declarada e inicializada correctamente como " + t);
                      } else {
                          System.err.println("Error: tipos incompatibles en inicializacion de " + id);
                      }
                  }
              }
              
              parser.updateVariableType(id.toString(), t.toString());
              
              if (parser.codeGenerationEnabled && declared) {
                  parser.getCodeGenerator().declareVariable(id.toString(), t.toString());
                  if (e != null) {
                      String expKey = parser.popCodeKey();
                      String expCode = parser.getCodeValue(expKey);
                      
                      System.out.println("DEBUG s1: Expresión para " + id + " = " + expCode + " (tipo: " + e + ")");
                      
                      if (parser.isInSwitchContext()) {
                          parser.deferSwitchCode(id.toString() + " = " + expCode);
                          System.out.println("DEBUG: Inicialización diferida para switch: " + id + " = " + expCode);
                      } else {
                          parser.getCodeGenerator().generateAssignment(id.toString(), expCode);
                          System.out.println("DEBUG s1: Variable " + id + " inicializada con " + expCode);
                      }
                  }
              }
           :}
           | tipo:t ID:id QUESTION
           {: 
              boolean declared = parser.getSemanticTable().declareVariable(id.toString(), t, idleft, idright, false);
              
              if (declared) {
                  System.out.println("Variable '" + id + "' declarada como " + t + " (sin inicializar)");
              }
              
              parser.updateVariableType(id.toString(), t.toString());
              
              if (parser.codeGenerationEnabled && declared) {
                  parser.getCodeGenerator().declareVariable(id.toString(), t.toString());
              }
           :}
           ;

/* Valores literales con tipos semánticos */
literal ::= LIT_INT:val
          {: 
             RESULT = "INT";
             System.out.println("Literal entero: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("INT", val.toString());
                 parser.pushCodeKey(key);  // Guardar en stack para uso posterior
                 System.out.println("DEBUG: Literal " + val + " guardado con clave " + key);
             }
          :}
         | LIT_FLOAT:val
          {: 
             RESULT = "FLOAT";
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("FLOAT", val.toString());
                 parser.pushCodeKey(key);
             }
          :}
         | LIT_BOOL:val
          {: 
             RESULT = "BOOL";
             System.out.println("Literal booleano detectado: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("BOOL", val.toString());  
                 parser.pushCodeKey(key);
                 System.out.println("DEBUG: Literal BOOL " + val + " guardado como código");
             }
          :}
         | LIT_CHAR:val
          {: 
             RESULT = "CHAR";
             System.out.println("Literal caracter detectado: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("CHAR", val.toString()); 
                 parser.pushCodeKey(key);
                 System.out.println("DEBUG: Literal CHAR " + val + " guardado como código");
             }
          :}
         | LIT_STRING:val
          {: 
             RESULT = "STRING";
             System.out.println("Literal cadena detectado: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("STRING", val.toString());  
                 parser.pushCodeKey(key);
                 System.out.println("DEBUG: Literal STRING " + val + " guardado como código");
             }
          :}
         | TRUE 
          {: 
              RESULT = "BOOL";
              if (parser.codeGenerationEnabled) {
                  String key = parser.saveCodeValue("BOOL", "true");
                  parser.pushCodeKey(key);
              }
           :}
         | FALSE 
          {: 
              RESULT = "BOOL";
              if (parser.codeGenerationEnabled) {
                  String key = parser.saveCodeValue("BOOL", "false");
                  parser.pushCodeKey(key);
              }
           :}
         ;

/* Llamadas a funciones con verificación semántica Y GENERACIÓN DE CÓDIGO */
llamada_fun ::= ID:id LPAREN arg_list:args RPAREN
              {: 
                 System.out.println("DEBUG s1: ========== LLAMADA A FUNCIÓN ==========");
                 System.out.println("DEBUG s1: Función: " + id);
                 if (args != null) {
                     List<String> argTypes = (List<String>) args;
                     System.out.println("DEBUG s1: Número de argumentos: " + argTypes.size());
                     for (int i = 0; i < argTypes.size(); i++) {
                         System.out.println("DEBUG s1: Argumento " + (i+1) + ": " + argTypes.get(i));
                     }
                 }
                 
                 if (parser.getSemanticTable() != null) {
                     List<String> argTypes = new ArrayList<String>();
                     if (args != null) {
                         List<String> argList = (List<String>) args;
                         for (String arg : argList) {
                             argTypes.add(arg); 
                         }
                     }
                     
                     System.out.println("DEBUG s1: Tipos para validación: " + argTypes);
                     String returnType = parser.getSemanticTable().checkFunctionCall(
                         id.toString(), argTypes, idleft
                     );
                     
                     if (returnType == null) {
                         RESULT = "ERROR";
                         System.out.println("DEBUG s1: Validación FALLÓ");
                     } else {
                         RESULT = returnType;
                         System.out.println("DEBUG s1: Validación OK -> " + returnType);
                     }
                 } else {
                     RESULT = "ERROR";
                 }

                 if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                     List<String> argCodes = new ArrayList<String>();
                     if (args != null) {
                         List<String> argList = (List<String>) args;
                         
                         for (int i = argList.size() - 1; i >= 0; i--) {
                             String argKey = parser.popCodeKey();
                             String argCode = parser.getCodeValue(argKey);
                             argCodes.add(0, argCode);  
                             System.out.println("DEBUG s1: Argumento " + i + " código: " + argCode);
                         }
                     }
                     
                     String tempResult = parser.getCodeGenerator().generateFunctionCallComplete(
                         id.toString(), argCodes, RESULT
                     );
                     
                     String resultKey = parser.saveCodeValue(RESULT, tempResult);
                     parser.pushCodeKey(resultKey);
                     
                     System.out.println("DEBUG s1: Resultado guardado: " + tempResult + " con clave " + resultKey);
                 }
                 
                 System.out.println("DEBUG s1: ========================================");
              :}
              | ID:id LPAREN RPAREN
              {: 
                 System.out.println("DEBUG s1: Función sin argumentos: " + id);
                 
                 if (parser.getSemanticTable() != null) {
                     List<String> noArgs = new ArrayList<String>();
                     String returnType = parser.getSemanticTable().checkFunctionCall(
                         id.toString(), noArgs, idleft
                     );
                     
                     if (returnType == null) {
                         RESULT = "ERROR";
                     } else {
                         RESULT = returnType;
                     }
                 } else {
                     RESULT = "ERROR";
                 }
                 
                 if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                     List<String> noArgs = new ArrayList<String>();
                     String tempResult = parser.getCodeGenerator().generateFunctionCallComplete(
                         id.toString(), noArgs, RESULT
                     );
                     
                     String resultKey = parser.saveCodeValue(RESULT, tempResult);
                     parser.pushCodeKey(resultKey);
                 }
              :}
              ;

/* Punto de entrada para expresiones con propagación de tipos */
exp ::= exp_log:e {: RESULT = e; :}
      ;

/* Expresiones lógicas con verificación de tipos */
exp_log ::= exp_log:e1 OR term_log:e2
          {: 
             String resultType = parser.getSemanticTable().checkLogicalOperation(
                 e1, e2, "||", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Operación lógica OR requiere operandos booleanos", null);
             } else {
                 RESULT = resultType; 
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "||", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | term_log:e {: RESULT = e; :}
          ;


term_log ::= term_log:e1 AND factor_log:e2
           {: 
              String resultType = parser.getSemanticTable().checkLogicalOperation(
                  e1, e2, "&&", e1left
              );
              if (resultType == null) {
                  RESULT = "ERROR";
                  parser.report_error("Operación lógica AND requiere operandos booleanos", null);
              } else {
                  RESULT = resultType;
              }
              
              if (parser.codeGenerationEnabled && resultType != null) {
                  String rightKey = parser.popCodeKey();
                  String leftKey = parser.popCodeKey();
                  String rightCode = parser.getCodeValue(rightKey);
                  String leftCode = parser.getCodeValue(leftKey);
                  
                  String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "&&", rightCode);
                  String newKey = parser.saveCodeValue(resultType, tempVar);
                  parser.pushCodeKey(newKey);
              }
           :}
           | factor_log:e {: RESULT = e; :}
           ;

factor_log ::= NOT atom_arit:e
             {: 
                String resultType = parser.getSemanticTable().checkLogicalOperation(
                    e, null, "!", eleft
                );
                if (resultType == null) {
                    RESULT = "ERROR";
                    parser.report_error("Operación NOT requiere operando booleano", null);
                } else {
                    RESULT = resultType;
                }
                
                if (parser.codeGenerationEnabled && resultType != null) {
                    String operandKey = parser.popCodeKey();
                    String operandCode = parser.getCodeValue(operandKey);
                    
                    String tempVar = parser.getCodeGenerator().generateUnaryOp("!", operandCode);
                    String newKey = parser.saveCodeValue(resultType, tempVar);
                    parser.pushCodeKey(newKey);
                }
             :}
             | exp_rel:e {: RESULT = e; :}
             | LPAREN exp_log:e RPAREN {: RESULT = e; :}
             ;

/* Expresiones relacionales con verificación de tipos */
exp_rel ::= exp_arit:e1 LT exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "<", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación <", null);
             } else {
                 RESULT = resultType;  
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "<", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 LTE exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "<=", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación <=", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "<=", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 GT exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, ">", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación >", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, ">", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 GTE exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, ">=", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación >=", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, ">=", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 EQ exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "==", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación ==", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "==", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 NEQ exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "!=", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación !=", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "!=", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e {: RESULT = e; :}
          ;

/* Expresiones aritméticas con propagación de tipos */
exp_arit ::= exp_arit:e1 PLUS term_arit:e2
           {: 
              String resultType = parser.getSemanticTable().checkArithmeticOperation(
                  e1, e2, "+", e1left
              );
              if (resultType == null) {
                  RESULT = "ERROR";
                  parser.report_error("Tipos incompatibles en operación +", null);
              } else {
                  RESULT = resultType; 
              }
              
              if (parser.codeGenerationEnabled && resultType != null) {
                  String rightKey = parser.popCodeKey(); 
                  String leftKey = parser.popCodeKey();   
                  String rightCode = parser.getCodeValue(rightKey);
                  String leftCode = parser.getCodeValue(leftKey);
                  
                  String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "+", rightCode);
                  String newKey = parser.saveCodeValue(resultType, tempVar);
                  parser.pushCodeKey(newKey);
              }
           :}
           | exp_arit:e1 MINUS term_arit:e2 
           {: 
              String resultType = parser.getSemanticTable().checkArithmeticOperation(
                  e1, e2, "-", e1left
              );
              if (resultType == null) {
                  RESULT = "ERROR";
                  parser.report_error("Tipos incompatibles en operación -", null);
              } else {
                  RESULT = resultType;
              }
              
              if (parser.codeGenerationEnabled && resultType != null) {
                  String rightKey = parser.popCodeKey();
                  String leftKey = parser.popCodeKey();
                  String rightCode = parser.getCodeValue(rightKey);
                  String leftCode = parser.getCodeValue(leftKey);
                  
                  String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "-", rightCode);
                  String newKey = parser.saveCodeValue(resultType, tempVar);
                  parser.pushCodeKey(newKey);
              }
           :}
           | term_arit:e {: RESULT = e; :}
           ;

term_arit ::= term_arit:e1 TIMES factor_arit:e2 
            {: 
               String resultType = parser.getSemanticTable().checkArithmeticOperation(
                   e1, e2, "*", e1left
               );
               if (resultType == null) {
                   RESULT = "ERROR";
                   parser.report_error("Tipos incompatibles en operación *", null);
               } else {
                   RESULT = resultType;
               }
               
               if (parser.codeGenerationEnabled && resultType != null) {
                   String rightKey = parser.popCodeKey();
                   String leftKey = parser.popCodeKey();
                   String rightCode = parser.getCodeValue(rightKey);
                   String leftCode = parser.getCodeValue(leftKey);
                   
                   String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "*", rightCode);
                   String newKey = parser.saveCodeValue(resultType, tempVar);
                   parser.pushCodeKey(newKey);
               }
            :}
            | term_arit:e1 DIVIDE factor_arit:e2 
            {: 
               String resultType = parser.getSemanticTable().checkArithmeticOperation(
                   e1, e2, "/", e1left
               );
               if (resultType == null) {
                   RESULT = "ERROR";
                   parser.report_error("Tipos incompatibles en operación /", null);
               } else {
                   RESULT = resultType;
               }
               
               if (parser.codeGenerationEnabled && resultType != null) {
                   String rightKey = parser.popCodeKey();
                   String leftKey = parser.popCodeKey();
                   String rightCode = parser.getCodeValue(rightKey);
                   String leftCode = parser.getCodeValue(leftKey);
                   
                   String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "/", rightCode);
                   String newKey = parser.saveCodeValue(resultType, tempVar);
                   parser.pushCodeKey(newKey);
               }
            :}
            | term_arit:e1 MOD factor_arit:e2 
            {: 
               if (!e1.equals("INT") || !e2.equals("INT")) {
                   parser.report_error("Operador % requiere operandos enteros", null);
                   RESULT = "ERROR";
               } else {
                   RESULT = "INT";
               }
               
               if (parser.codeGenerationEnabled && RESULT.equals("INT")) {
                   String rightKey = parser.popCodeKey();
                   String leftKey = parser.popCodeKey();
                   String rightCode = parser.getCodeValue(rightKey);
                   String leftCode = parser.getCodeValue(leftKey);
                   
                   String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "%", rightCode);
                   String newKey = parser.saveCodeValue("INT", tempVar);
                   parser.pushCodeKey(newKey);
               }
            :}
            | factor_arit:e {: RESULT = e; :}
            ;

factor_arit ::= factor_arit:e1 POW power_arit:e2 
              {: 
                 String resultType = parser.getSemanticTable().checkArithmeticOperation(
                     e1, e2, "**", e1left
                 );
                 if (resultType == null) {
                     RESULT = "ERROR";
                     parser.report_error("Operación POW requiere operandos numéricos", null);
                 } else {
                     if (e1.equals("INT") && e2.equals("INT")) {
                         RESULT = "INT";
                     } else {
                         RESULT = "FLOAT";
                     }
                 }
                 
                 if (parser.codeGenerationEnabled && resultType != null) {
                     String rightKey = parser.popCodeKey();
                     String leftKey = parser.popCodeKey();
                     String rightCode = parser.getCodeValue(rightKey);
                     String leftCode = parser.getCodeValue(leftKey);
                     
                     String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "**", rightCode);
                     String newKey = parser.saveCodeValue(RESULT, tempVar);
                     parser.pushCodeKey(newKey);
                 }
              :}
              | power_arit:e {: RESULT = e; :}
              ;

power_arit ::= unary_exp:e {: RESULT = e; :}
            ;

/* Operadores unarios con verificación de tipos */
unary_exp ::= MINUS atom_arit:e
            {: 
               if (!e.equals("INT") && !e.equals("FLOAT")) {
                   parser.report_error("Operador unario - requiere operando numérico (INT o FLOAT), encontrado: " + e, null);
                   RESULT = "ERROR";
               } else {
                   RESULT = e; 
               }
               
               if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                   String operandKey = parser.popCodeKey();
                   String operandCode = parser.getCodeValue(operandKey);
                   
                   String tempVar = parser.getCodeGenerator().generateUnaryOp("-", operandCode);
                   String newKey = parser.saveCodeValue(RESULT, tempVar);
                   parser.pushCodeKey(newKey);
                   
                   System.out.println("DEBUG: Menos unario: -" + operandCode + " = " + tempVar);
               }
            :}
            | INCREMENT ID:id
            {: 
               if (parser.getSemanticTable() != null) {
                   SymbolInfo var = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (var == null) {
                       RESULT = "ERROR";
                   } else if (!var.getTipoVariable().equals("INT") && !var.getTipoVariable().equals("FLOAT")) {
                       parser.report_error("Operador ++ requiere variable numérica", null);
                       RESULT = "ERROR";
                   } else {
                       RESULT = var.getTipoVariable();
                   }
               } else {
                   RESULT = "ERROR";
               }
               
               if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                   String tempVar = parser.getCodeGenerator().generateIncrement(id.toString());
                   String newKey = parser.saveCodeValue(RESULT, tempVar);
                   parser.pushCodeKey(newKey);
                   
                   System.out.println("DEBUG: Incremento: ++" + id + " = " + tempVar);
               }
            :}
            | DECREMENT ID:id
            {: 
               if (parser.getSemanticTable() != null) {
                   SymbolInfo var = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (var == null) {
                       RESULT = "ERROR";
                   } else if (!var.getTipoVariable().equals("INT") && !var.getTipoVariable().equals("FLOAT")) {
                       parser.report_error("Operador -- requiere variable numérica", null);
                       RESULT = "ERROR";
                   } else {
                       RESULT = var.getTipoVariable();
                   }
               } else {
                   RESULT = "ERROR";
               }
               
               if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                   String tempVar = parser.getCodeGenerator().generateDecrement(id.toString());
                   String newKey = parser.saveCodeValue(RESULT, tempVar);
                   parser.pushCodeKey(newKey);
                   
                   System.out.println("DEBUG: Decremento: --" + id + " = " + tempVar);
               }
            :}
            | atom_arit:e {: RESULT = e; :}
            ;

/* Términos atómicos con tipos semánticos */
atom_arit ::= ID:id
            {: 
               if (parser.getSemanticTable() != null) {
                   SymbolInfo symbol = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (symbol != null) {
                       RESULT = symbol.getTipoVariable(); 
                       
                       if (parser.codeGenerationEnabled) {
                           String key = parser.saveCodeValue(RESULT, id.toString());
                           parser.pushCodeKey(key);
                           System.out.println("DEBUG: Variable " + id + " guardada con clave " + key);
                       }
                   } else {
                       RESULT = "ERROR";
                   }
               } else {
                   RESULT = "ERROR";
               }

            :}
            | literal:l {: RESULT = l; :}
            | arr_access:a {: RESULT = a; :}
            | llamada_fun:f 
            {: 
                RESULT = f; 
                System.out.println("DEBUG s1: Llamada a función procesada en atom_arit: " + f);
            :}
            | LPAREN exp:e RPAREN {: RESULT = e; :}
            ;

/* Lista de argumentos */
arg_list ::= exp:e
           {: 
              List<String> argList = new ArrayList<String>();
              if (e != null) {
                  argList.add(e.toString());
                  System.out.println("DEBUG s1: Argumento único agregado: " + e.toString());
              }
              RESULT = argList;
              System.out.println("DEBUG s1: Lista final con " + argList.size() + " argumentos: " + argList);
           :}
           | arg_list:list COMMA exp:e
           {: 
              List<String> argList = new ArrayList<String>();
              if (list != null) {
                  List<String> existingList = (List<String>) list;
                  argList.addAll(existingList);  
                  System.out.println("DEBUG s1: Argumentos existentes: " + existingList.size());
              }
              if (e != null) {
                  argList.add(e.toString());  
                  System.out.println("DEBUG s1: Nuevo argumento agregado: " + e.toString());
              }
              RESULT = argList;
              System.out.println("DEBUG s1: Lista total con " + argList.size() + " argumentos: " + argList);
           :}
           ;

/* Estructuras de control */
ctrl ::= if_stmt:s
        {:
            RESULT = s;
        :}
       | do_while
       | for_stmt
       | switch_stmt
       ;

/* Estructura if-elif-else con scopes semánticos */
if_stmt ::= IF LPAREN exp:e RPAREN LBLOCK block:then_block RBLOCK
          {: 
             if (!e.equals("BOOL")) {
                 parser.report_error("Condición de IF debe ser booleana", null);
                 RESULT = "ERROR";
             } else {
                 RESULT = "VOID";
             }
             
             if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                 String conditionKey = parser.popCodeKey();
                 String conditionCode = parser.getCodeValue(conditionKey);
                 String endLabel = parser.generateLabel();
                 
                 parser.getCodeGenerator().insertConditionalBeforeBlock("IF NOT " + conditionCode + " GOTO " + endLabel);
                 parser.getCodeGenerator().emit(endLabel + ":");
                 
                 System.out.println("DEBUG s4: IF simple - condición diferida: " + conditionCode);
             }
          :}
          
          | IF LPAREN exp:e RPAREN LBLOCK block:then_block RBLOCK ELSE LBLOCK block:else_block RBLOCK
          {: 
             if (!e.equals("BOOL")) {
                 parser.report_error("Condición de IF-ELSE debe ser booleana", null);
                 RESULT = "ERROR";
             } else {
                 RESULT = "VOID";
             }
             
             if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                 String conditionKey = parser.popCodeKey();
                 String conditionCode = parser.getCodeValue(conditionKey);
                 String elseLabel = parser.generateLabel();
                 String endLabel = parser.generateLabel();
                 
                 parser.getCodeGenerator().generateDeferredIfElse(conditionCode, elseLabel, endLabel);
                 System.out.println("DEBUG s4: IF-ELSE diferido generado");
             }
          :}
          ;


/* Estructura do-while con scope semántico*/
do_while ::= DO 
           {: 
              String startLabel = parser.generateLabel();
              String endLabel = parser.generateLabel();
              parser.pushLoopLabels(startLabel, endLabel);
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().generateLabel(startLabel);
                  System.out.println("DEBUG: DO-WHILE iniciado - etiqueta: " + startLabel);
              }
           :}
           LBLOCK block:body RBLOCK WHILE LPAREN exp:condition RPAREN QUESTION
           {: 
              if (!condition.equals("BOOL")) {
                  parser.report_error("Condición de DO-WHILE debe ser booleana", null);
                  RESULT = "ERROR";
              } else {
                  RESULT = "VOID";
              }
              
              if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                  String conditionKey = parser.popCodeKey();
                  String conditionCode = parser.getCodeValue(conditionKey);
                  
                  String[] labels = parser.peekLoopLabels();
                  String startLabel = labels[0];
                  String endLabel = labels[1];
                  
                  parser.getCodeGenerator().emit("IF " + conditionCode + " GOTO " + startLabel);
                  
                  parser.getCodeGenerator().generateLabel(endLabel);
                  
                  System.out.println("DEBUG s2: DO-WHILE - condición TRUE repite: " + conditionCode + " -> " + startLabel);
              }
              
              parser.popLoopLabels();
           :}
           ;

/* Estructura for con scope semántico */
for_stmt ::= FOR LPAREN decl_var:init exp:condition QUESTION exp:update RPAREN LBLOCK 
           {: 
              String startLabel = parser.generateLabel();
              String endLabel = parser.generateLabel();
              parser.pushLoopLabels(startLabel, endLabel);
              System.out.println("DEBUG: FOR iniciado - start: " + startLabel + ", end: " + endLabel);
           :}
           block:body RBLOCK
           {: 
              if (!condition.equals("BOOL")) {
                  parser.report_error("Condición de FOR debe ser booleana", null);
                  RESULT = "ERROR";
              } else {
                  RESULT = "VOID";
              }
              
              if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                  String updateKey = parser.popCodeKey();
                  String updateCode = parser.getCodeValue(updateKey);
                  
                  String conditionKey = parser.popCodeKey();
                  String conditionCode = parser.getCodeValue(conditionKey);
                  
                  String[] labels = parser.peekLoopLabels();
                  String startLabel = labels[0];
                  String endLabel = labels[1];
                  
                  parser.getCodeGenerator().generateForWithExistingGrammar(conditionCode, updateCode, startLabel, endLabel);
                  
                  System.out.println("DEBUG: FOR - condición: " + conditionCode + ", update: " + updateCode);
                  parser.getCodeGenerator().cleanupForLoop();

              }
              
              parser.popLoopLabels();
           :}
           ;
/* ESTRUCTURA SWITCH  */
switch_stmt ::= SWITCH
                {: 
                 parser.enterSwitchContext();
                 System.out.println("DEBUG: INICIANDO SWITCH - modo diferido activado");
              :} 
            LPAREN exp:switchExpr RPAREN LBLOCK case_list:cases RBLOCK
              {: 
                 if (parser.codeGenerationEnabled) {
                     String switchKey = parser.popCodeKey();
                     String switchValue = parser.getCodeValue(switchKey);
                     
                     String exitLabel = parser.generateLabel();
                     
                     parser.getCodeGenerator().generateCompleteSwitchWithDeferred(switchValue, exitLabel, parser.getDeferredSwitchCode());
                     
                     System.out.println("DEBUG: SWITCH generado - expr: " + switchValue + " -> " + exitLabel);
                 }
                 
                 parser.exitSwitchContext();
              :}
              ;

/* Lista de casos */
case_list ::= case_stmt case_list
           | default_stmt
           | /* vacío */
           ;

case_stmt ::= CASE exp:caseValue COLON block:caseBlock
            {: 
               if (parser.codeGenerationEnabled) {
                   String caseKey = parser.popCodeKey();
                   String caseVal = parser.getCodeValue(caseKey);
                   
                   String caseLabel = parser.generateLabel();
                   
                   parser.getCodeGenerator().registerCase(caseVal, caseLabel);
                   
                   System.out.println("DEBUG: CASE registrado - valor: " + caseVal + " -> " + caseLabel);
               }
            :}
            ;

/* DEFAULT */
default_stmt ::= DEFAULT COLON block:defaultBlock
               {: 
                  if (parser.codeGenerationEnabled) {
                      String defaultLabel = parser.generateLabel();
                      
                      parser.getCodeGenerator().registerDefault(defaultLabel);
                      
                      System.out.println("DEBUG: DEFAULT registrado -> " + defaultLabel);
                  }
               :}
               ;

/* BREAK  PARA SWITCH Y LOOPS */
break_stmt ::= BREAK QUESTION
             {: 
                if (parser.codeGenerationEnabled) {
                    if (parser.isInSwitchContext()) {
                        parser.deferSwitchCode("BREAK");
                        System.out.println("DEBUG: Break diferido para switch");
                    } 
                    else {
                        String[] loopLabels = parser.peekLoopLabels();
                        if (loopLabels != null) {
                            String endLabel = loopLabels[1]; 
                            parser.getCodeGenerator().generateBreakToLabel(endLabel);
                            System.out.println("DEBUG: Break generado para loop -> " + endLabel);
                        } else {
                            parser.getCodeGenerator().generateBreak();
                            System.out.println("DEBUG: Break genérico");
                        }
                    }
                }
             :}
             ;
/* CONTINUE PARA LOOPS */
continue_stmt ::= CONTINUE QUESTION
                {: 
                   if (parser.codeGenerationEnabled) {
                       String[] loopLabels = parser.peekLoopLabels();
                       if (loopLabels != null) {
                           String startLabel = loopLabels[0];  
                           parser.getCodeGenerator().generateContinue(startLabel);
                           System.out.println("DEBUG: Continue generado -> " + startLabel);
                       } else {
                           parser.report_error("CONTINUE solo puede usarse dentro de un loop", null);
                       }
                   }
                :}
                ;

/* Sentencia return con verificación de tipos */
return_stmt ::= RETURN exp:e QUESTION
              {: 
                 System.out.println("DEBUG: Return con expresión, función actual: " + parser.getCurrentFunctionName());
                 
                 if (parser.getSemanticTable() != null && parser.getCurrentFunctionName() != null) {
                     parser.getSemanticTable().checkReturnStatement(parser.getCurrentFunctionName(), e, eleft);
                 } else {
                     System.err.println("ERROR: No se puede verificar return - función actual: " + parser.getCurrentFunctionName());
                 }
                 
                 if (parser.codeGenerationEnabled) {
                     String expKey = parser.popCodeKey();
                     
                     if (expKey != null) {
                         String expValue = parser.getCodeValue(expKey);
                         parser.getCodeGenerator().generateReturnWithValue(expValue);
                         System.out.println("DEBUG: Return generado con valor: " + expValue + " (clave: " + expKey + ")");
                     } else {
                         parser.getCodeGenerator().generateReturnWithValue(e.toString());
                         System.out.println("DEBUG: Return generado con valor directo: " + e.toString());
                     }
                 }
              :}
              | RETURN:r QUESTION
              {: 
                 System.out.println("DEBUG: Return sin expresión, función actual: " + parser.getCurrentFunctionName());
                 
                 if (parser.getSemanticTable() != null && parser.getCurrentFunctionName() != null) {
                     parser.getSemanticTable().checkReturnStatement(parser.getCurrentFunctionName(), null, rleft);
                 } else {
                     System.err.println("ERROR: No se puede verificar return - función actual: " + parser.getCurrentFunctionName());
                 }
                 
                 if (parser.codeGenerationEnabled) {
                     parser.getCodeGenerator().generateReturnVoid();
                     System.out.println("DEBUG: Return void generado");
                 }
              :}
              | RETURN error QUESTION  {: System.err.println("Error en expresión RETURN. Continuando..."); :}
              ;

/* Funciones de entrada/salida */
read_stmt ::= READ LPAREN ID:id RPAREN QUESTION
            {: 
               if (parser.getSemanticTable() != null) {
                   SymbolInfo var = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (var == null) {
                       parser.report_error("Variable '" + id + "' no declarada en READ", null);
                   } else {
                       var.setInicializada(true); 
                       System.out.println("DEBUG: READ de variable '" + id + "' tipo " + var.getTipoVariable());
                   }
               }
               
               if (parser.codeGenerationEnabled) {
                   parser.getCodeGenerator().generateRead(id.toString());
                   System.out.println("DEBUG: READ generado para " + id);
               }
            :}
            | READ LPAREN error RPAREN QUESTION  
            {: 
                parser.report_error("Error en función read - argumento inválido", null); 
            :}
            ;

write_stmt ::= WRITE LPAREN exp:e RPAREN QUESTION
             {: 
                System.out.println("DEBUG: WRITE con expresión: " + e);
                
                if (e != null && e.equals("ERROR")) {
                    parser.report_error("Expresión inválida en write", null);
                }
                
                if (parser.codeGenerationEnabled && !e.equals("ERROR")) {
                    String expKey = parser.popCodeKey();
                    
                    if (expKey != null) {
                        String expValue = parser.getCodeValue(expKey);
                        parser.getCodeGenerator().generateWrite(expValue);
                        System.out.println("DEBUG: WRITE generado con valor: " + expValue + " (clave: " + expKey + ")");
                    } else {
                        parser.getCodeGenerator().generateWrite(e.toString());
                        System.out.println("DEBUG: WRITE generado con valor directo: " + e);
                    }
                }
             :}
             | WRITE LPAREN error RPAREN QUESTION  
             {: 
                 parser.report_error("Error en función write - expresión inválida", null); 
             :}
             ;

