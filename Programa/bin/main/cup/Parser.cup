/* 
 * Analizador Sintáctico con Análisis Semántico Integrado + Código Intermedio
 * --------------------------------------------------------------------------
 * 
 * CAMBIOS PARA PROYECTO 2:
 * - Manejo de scopes y tabla de símbolos semántica
 * - Verificación de tipos y compatibilidad
 * - Detección de errores semánticos
 * 
 */

/* Imports y paquetes */
import java_cup.runtime.*;
import java.util.*;
import main.java.symbol.SymbolTable;
import main.java.symbol.SemanticSymbolTable;
import main.java.symbol.SymbolInfo;
import main.java.intermedio.IntermediateCodeGenerator;

/* Código de usuario */
parser code {:

    private SemanticSymbolTable semanticTable;
    
    private SymbolTable symbolTable;
    
    private int errorCount = 0;

    private Stack<String> scopeContext = new Stack<>();
    
    private String currentFunctionName = null;

    private Map<String, String> codeValues  = new HashMap<>();

    private int uniqueCounter  = 0;
    
    private IntermediateCodeGenerator codeGenerator;

    private boolean codeGenerationEnabled = false;

    private int labelCounter = 0;

    private Stack<String> labelStack = new Stack<>();
    private Stack<String[]> labelPairStack = new Stack<>();

    private boolean inSwitchContext = false;
    private List<String> deferredSwitchCode = new ArrayList<>();
    
    public void enableCodeGeneration(String outputFile) {
        this.codeGenerator = new IntermediateCodeGenerator(outputFile);
        this.codeGenerationEnabled = true;
        System.out.println("Generación de código intermedio habilitada");
    }
    
    public void disableCodeGeneration() {
        this.codeGenerationEnabled = false;
        this.codeGenerator = null;
    }
    
    public IntermediateCodeGenerator getCodeGenerator() {
        return codeGenerator;
    }

    public void initTables() {
        semanticTable = new SemanticSymbolTable();
        symbolTable = semanticTable.getOriginalTable();
        System.out.println("Iniciando analisis semantico...");
        
        scopeContext.push("GLOBAL");
    }
    
    public void setSymbolTable(SymbolTable symbolTable) {
        this.symbolTable = symbolTable;
        if (semanticTable == null) {
            initTables();
        }
    }
    
    public SemanticSymbolTable getSemanticTable() {
        if (semanticTable == null) {
            initTables();
        }
        return semanticTable;
    }

    public String getCurrentFunctionName() {
        return currentFunctionName;
    }
    
    public void setCurrentFunctionName(String functionName) {
        this.currentFunctionName = functionName;
    }
    
    public void enterFunctionScope(String functionName, String returnType, List<String> params, int line, int column) {
        if (semanticTable != null) {
            semanticTable.enterScope("FUNCTION", functionName);
            scopeContext.push("FUNCTION:" + functionName);
            setCurrentFunctionName(functionName); 
            System.out.println("Entrando a función: " + functionName);
        }
    }
    
    public void exitFunctionScope() {
        if (semanticTable != null && !scopeContext.isEmpty()) {
            String context = scopeContext.pop();
            semanticTable.exitScope();
            setCurrentFunctionName(null);
            System.out.println("Saliendo de scope: " + context);
        }
    }
    
    public void enterBlockScope() {
        if (semanticTable != null) {
            semanticTable.enterScope("BLOCK", "block");
            scopeContext.push("BLOCK");
            System.out.println("Entrando a bloque...");
        }
    }
    
    public void exitBlockScope() {
        if (semanticTable != null && !scopeContext.isEmpty()) {
            String context = scopeContext.pop();
            semanticTable.exitScope();
            System.out.println("Saliendo de bloque...");
        }
    }
    
    public void enterControlScope(String controlType) {
        if (semanticTable != null) {
            semanticTable.enterScope(controlType.toUpperCase(), controlType.toLowerCase() + "_block");
            scopeContext.push(controlType.toUpperCase());
            System.out.println("Entrando a " + controlType + "...");
        }
    }
    
    public void exitControlScope() {
        if (semanticTable != null && !scopeContext.isEmpty()) {
            String context = scopeContext.pop();
            semanticTable.exitScope();
            System.out.println("Saliendo de control: " + context);
        }
    }
    
    public void finalizeSemantic() {
        if (semanticTable != null) {
            boolean hasMain = semanticTable.checkMainFunction();
            if (!hasMain) {
                errorCount++;
            }
            
            semanticTable.printSummary();
            
            try {
                semanticTable.escribirTablas("semantic_analysis.txt");
                System.out.println("Analisis semantico completado. Ver: semantic_analysis.txt");
            } catch (Exception e) {
                System.err.println("Error escribiendo archivo semantico: " + e.getMessage());
            }
        }
        
        if (codeGenerationEnabled && codeGenerator != null) {
            codeGenerator.printCode();
            codeGenerator.printStatistics();
            codeGenerator.writeToFile();
        }
    }
    
    /* Métodos de manejo de errores existentes */
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintactico #" + errorCount + " en linea " + (s.left + 1) + 
                          ", columna " + (s.right + 1) + ": Token inesperado '" + s.value + "'");
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        errorCount++;
        System.err.println("Error sintactico fatal #" + errorCount + " en linea " + (s.left + 1) + 
                          ", columna " + (s.right + 1) + ": No se pudo recuperar del error");
        
        System.err.println("Total de errores encontrados: " + errorCount);
        
        finalizeSemantic();
    }
    
    public void report_error(String message, Object info) {
        errorCount++;
        if (info instanceof Symbol) {
            Symbol s = (Symbol) info;
            System.err.println("Error de recuperacion #" + errorCount + " en linea " + (s.left + 1) + 
                              ", columna " + (s.right + 1) + ": " + message);
        } else {
            System.err.println("Error de recuperacion #" + errorCount + ": " + message);
        }
    }
    
    public int getErrorCount() {
        return errorCount + (semanticTable != null ? semanticTable.getErrorCount() : 0);
    }
    
    /* Métodos de compatibilidad existentes */
    public void updateVariableType(String id, String type) {
        if (symbolTable != null) {
            symbolTable.actualizarTipoVariable(id, type);
        }
    }
    
    public void markAsFunction(String id, String returnType) {
        if (symbolTable != null) {
            symbolTable.marcarComoFuncion(id, returnType);
        }
    }
    // Para el tema del código intermedio
    public String saveCodeValue(String semanticType, String codeValue) {
        if (codeGenerationEnabled && codeValue != null) {
            String uniqueKey = "expr_" + (++uniqueCounter);
            codeValues.put(uniqueKey, codeValue);
            System.out.println("DEBUG: Guardando " + uniqueKey + " = " + codeValue + " (tipo: " + semanticType + ")");
            return uniqueKey;  // Devolver la clave única
        }
        return null;
    }

    public String getCodeValue(String key) {
        if (key != null && key.startsWith("expr_")) {
            String value = codeValues.get(key);
            System.out.println("DEBUG: Recuperando " + key + " = " + value);
            return value != null ? value : key;
        }
        // Si no es una clave especial, devolver tal como está
        return key;
    }

    private Stack<String> codeKeyStack = new Stack<>();
    
    public void pushCodeKey(String key) {
        if (codeGenerationEnabled && key != null) {
            codeKeyStack.push(key);
        }
    }
    
    public String popCodeKey() {
        if (codeGenerationEnabled && !codeKeyStack.isEmpty()) {
            return codeKeyStack.pop();
        }
        return null;
    }

    // Para el tema de etiquetas únicas
    public String generateLabel() {
        return "L" + (++labelCounter);
    }

    public void pushLabel(String label) {
    labelStack.push(label);
}

public String popLabel() {
    return labelStack.isEmpty() ? null : labelStack.pop();
}

public void pushLabelPair(String label1, String label2) {
    labelPairStack.push(new String[]{label1, label2});
}

public String[] popLabelPair() {
    return labelPairStack.isEmpty() ? null : labelPairStack.pop();
}

public String[] peekLabelPair() {
    return labelPairStack.isEmpty() ? null : labelPairStack.peek();
}

public void enterSwitchContext() {
        inSwitchContext = true;
        deferredSwitchCode.clear();
        System.out.println("DEBUG: Entrando a contexto SWITCH - código diferido");
    }
    
    public void exitSwitchContext() {
        inSwitchContext = false;
        System.out.println("DEBUG: Saliendo de contexto SWITCH");
    }
    
    public boolean isInSwitchContext() {
        return inSwitchContext;
    }
    
    public void deferSwitchCode(String code) {
        if (inSwitchContext) {
            deferredSwitchCode.add(code);
            System.out.println("DEBUG: Código diferido para switch: " + code);
        }
    }
    
    public List<String> getDeferredSwitchCode() {
        return new ArrayList<>(deferredSwitchCode);
    }
:}

/* Declaración de terminales */
terminal IF, ELIF, ELSE, DO, WHILE, FOR, BREAK, RETURN;
terminal INT, FLOAT, BOOL, CHAR, STRING, VOID;
terminal READ, WRITE, MAIN, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, POW;
terminal INCREMENT, DECREMENT;
terminal LT, LTE, GT, GTE, EQ, NEQ;
terminal AND, OR, NOT;
terminal LPAREN, RPAREN, LBLOCK, RBLOCK;
terminal QUESTION, COMMA, ASSIGN;
terminal LBRACKET, RBRACKET;
terminal ID, LIT_INT, LIT_FLOAT, LIT_BOOL, LIT_CHAR, LIT_STRING;
terminal SWITCH, CASE, DEFAULT, COLON;

/* Declaración de no terminales */
non terminal program;
non terminal block;
non terminal decl_var, decl_fun, decl_arr;
non terminal stmt;
non terminal assign;
non terminal String exp;              
non terminal String exp_arit, term_arit, factor_arit, power_arit, atom_arit;
non terminal String exp_rel;          
non terminal String exp_log, term_log, factor_log;
non terminal String unary_exp;        
non terminal ctrl, if_stmt, do_while, for_stmt;
non terminal break_stmt, return_stmt;
non terminal read_stmt, write_stmt;
non terminal String tipo, tipo_r;     
non terminal String arr_access;      
non terminal exp_list, exp_matrix, matrix_row;
non terminal param, param_list, arg_list;
non terminal String literal;         
non terminal String llamada_fun;     
non terminal switch_stmt, case_list, case_stmt, default_stmt;


/* Precedencia de operadores */
precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc LT, LTE, GT, GTE, EQ, NEQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right POW;
precedence right INCREMENT, DECREMENT;
precedence left LPAREN, RPAREN, LBRACKET, RBRACKET;
precedence left ELSE;

/* 
 * Gramática con recuperación de errores y análisis semántico
 */
start with program;

/* 
 * Estructura del programa con manejo correcto de main
 */
program ::= VOID MAIN:m LPAREN RPAREN LBLOCK 
          {: 
             List<String> noParams = new ArrayList<String>();
             parser.getSemanticTable().declareFunction("main", "VOID", noParams, mleft, mright);
             
             parser.getSemanticTable().enterScope("FUNCTION", "main");
             parser.setCurrentFunctionName("main");
             System.out.println("Entrando a función main");
             
             if (parser.codeGenerationEnabled) {
                 parser.getCodeGenerator().startFunction("main", "VOID");
             }
          :}
          block RBLOCK
          {: 
             parser.getSemanticTable().exitScope();
             parser.setCurrentFunctionName(null);
             System.out.println("Saliendo de función main");
             
             if (parser.codeGenerationEnabled) {
                 parser.getCodeGenerator().endFunction("main");
             }
             
             parser.finalizeSemantic();
          :}
          | decl_fun:f program
          {: 
             if (f != null) {
                 System.out.println("Función declarada: " + f.toString());
             }
          :}
          | error program  
          {: 
             System.err.println("Error en la estructura del programa. Continuando análisis..."); 
          :}
          | /* programa vacío */
          ;

/* 
 * Declaración de funciones con análisis semántico y scope correcto
 */
decl_fun ::= tipo_r:t ID:id LPAREN param_list RPAREN LBLOCK 
           {: 
              List<String> params = new ArrayList<String>(); 
              parser.getSemanticTable().declareFunction(id.toString(), t.toString(), params, idleft, idright);
              
              parser.getSemanticTable().enterScope("FUNCTION", id.toString());
              parser.setCurrentFunctionName(id.toString());
              System.out.println("Entrando a función: " + id.toString() + " tipo: " + t.toString());
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().startFunction(id.toString(), t.toString());
              }
           :}
           block RBLOCK
           {: 
              RESULT = id; 
              
              parser.getSemanticTable().exitScope();
              parser.setCurrentFunctionName(null);
              System.out.println("Saliendo de función: " + id.toString());
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().endFunction(id.toString());
              }
              
              parser.markAsFunction(id.toString(), t.toString());
           :}
           | tipo_r:t ID:id LPAREN RPAREN LBLOCK 
           {: 
              List<String> noParams = new ArrayList<String>();
              parser.getSemanticTable().declareFunction(id.toString(), t.toString(), noParams, idleft, idright);
              
              parser.getSemanticTable().enterScope("FUNCTION", id.toString());
              parser.setCurrentFunctionName(id.toString());
              System.out.println("Entrando a función sin parámetros: " + id.toString() + " tipo: " + t.toString());
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().startFunction(id.toString(), t.toString());
              }
           :}
           block RBLOCK
           {: 
              RESULT = id; 
              
              parser.getSemanticTable().exitScope();
              parser.setCurrentFunctionName(null);
              System.out.println("Saliendo de función: " + id.toString());
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().endFunction(id.toString());
              }
              
              parser.markAsFunction(id.toString(), t.toString()); 
           :}
           ;

/* 
 * Tipos de retorno para funciones
 */
tipo_r ::= INT {: RESULT = "INT"; :}
         | FLOAT {: RESULT = "FLOAT"; :}
         | CHAR {: RESULT = "CHAR"; :}
         | BOOL {: RESULT = "BOOL"; :}
         | VOID {: RESULT = "VOID"; :}
         ;

/* 
 * Lista de parámetros de función
 */
param_list ::= param
             | param_list COMMA param
             ;

/* 
 * Parámetro individual con análisis semántico
 */
param ::= tipo:t ID:id 
        {: 
           if (parser.getSemanticTable() != null) {
               parser.getSemanticTable().declareVariable(id.toString(), t.toString(), idleft, idright);
           }
           
           if (parser.codeGenerationEnabled) {
               parser.getCodeGenerator().declareVariable(id.toString(), t.toString());
           }
           
           parser.updateVariableType(id.toString(), t.toString());
        :}
        ;

/* 
 * Bloque de código
 */
block ::= stmt block
        | error block  {: System.err.println("Error en bloque de código. Continuando..."); :}
        | /* bloque vacío */
        ;

/* 
 * Tipos de datos
 */
tipo ::= INT {: RESULT = "INT"; :}
       | FLOAT {: RESULT = "FLOAT"; :}
       | BOOL {: RESULT = "BOOL"; :}
       | CHAR {: RESULT = "CHAR"; :}
       | STRING {: RESULT = "STRING"; :}
       ;

/* 
 * Declaración de arreglos con análisis semántico
 */
decl_arr ::= tipo:t ID:id LBRACKET exp:e1 RBRACKET LBRACKET exp:e2 RBRACKET QUESTION
           {: 
              String arrayType = t.toString() + "[][]";
              
              if (parser.getSemanticTable() != null) {
                  parser.getSemanticTable().declareVariable(id.toString(), arrayType, idleft, idright);
              }
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().declareVariable(id.toString(), arrayType);
              }
              
              parser.updateVariableType(id.toString(), arrayType);
           :}
           | tipo:t ID:id LBRACKET exp:e1 RBRACKET LBRACKET exp:e2 RBRACKET ASSIGN exp_matrix QUESTION
           {: 
              String arrayType = t.toString() + "[][]";
              
              if (parser.getSemanticTable() != null) {
                  parser.getSemanticTable().declareVariable(id.toString(), arrayType, idleft, idright);
              }
              
              if (parser.codeGenerationEnabled) {
                  parser.getCodeGenerator().declareVariable(id.toString(), arrayType);
                  parser.getCodeGenerator().addComment("Array inicializado con matriz");
              }
              
              parser.updateVariableType(id.toString(), arrayType);
           :}
           ;

/* Estructura de matriz */
exp_matrix ::= LBRACKET matrix_row RBRACKET
             | LBRACKET matrix_row COMMA matrix_row RBRACKET
             ;

/* Fila de matriz */
matrix_row ::= LBRACKET exp_list RBRACKET;

/* Lista de expresiones */
exp_list ::= exp
           | exp COMMA exp_list
           ;

/* Acceso a arreglos con verificación semántica */
arr_access ::= ID:id LBRACKET exp:e1 RBRACKET LBRACKET exp:e2 RBRACKET
             {: 
                // VALIDACIÓN COMPLETA: Verificar tipo de array e índices
                if (parser.getSemanticTable() != null) {
                    String resultType = parser.getSemanticTable().checkArrayAccess(
                        id.toString(), e1, e2, idleft
                    );
                    
                    if (resultType == null) {
                        RESULT = "ERROR";
                    } else {
                        RESULT = resultType;
                    }                        
                } else {
                    RESULT = "ERROR";
                }

                if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                    String code = parser.getCodeGenerator().generateArrayAccess(id.toString(), e1, e2);
                }
             :}
             ;

/* 
 * Sentencias con manejo semántico de bloques
 */
stmt ::= exp:e QUESTION
       {: 
          if (parser.getSemanticTable() != null && e != null) {
              // Registro de uso de expresión
          }
       :}
       | assign
       | decl_var
       | decl_arr
       | ctrl
       | break_stmt
       | return_stmt
       | read_stmt
       | write_stmt
       | LBLOCK block RBLOCK
       {: 
          parser.enterBlockScope();
          parser.exitBlockScope();
       :}
       | error QUESTION  {: System.err.println("Error en sentencia. Recuperando en ';'..."); :}
       ;

/* 
 * Asignación con verificación de tipos 
 */
/* ASSIGN TAMBIÉN MODIFICADO PARA CONTEXTO SWITCH */
assign ::= ID:id ASSIGN exp:e QUESTION
         {:
            boolean valid = parser.getSemanticTable().checkAssignment(id.toString(), e, idleft);
            
            if (valid) {
                System.out.println("Asignacion valida: " + id + " = " + e);
                
                if (parser.codeGenerationEnabled && valid) {
                    String expKey = parser.popCodeKey();
                    String expCode = parser.getCodeValue(expKey);
                    
                    // ✅ SI ESTAMOS EN SWITCH, DIFERIR LA ASIGNACIÓN
                    if (parser.isInSwitchContext()) {
                        parser.deferSwitchCode(id.toString() + " = " + expCode);
                        System.out.println("DEBUG: Asignación diferida para switch: " + id + " = " + expCode);
                    } else {
                        // Generar normalmente
                        parser.getCodeGenerator().generateAssignment(id.toString(), expCode);
                        System.out.println("DEBUG: Asignación inmediata: " + id + " = " + expCode);
                    }
                }
            } else {
                System.err.println("Error en asignacion a variable: " + id);
            }
         :}
         ;

/* 
 * Declaración de variables con verificación semántica completa
 */
decl_var ::= tipo:t ID:id ASSIGN exp:e QUESTION
           {: 
              boolean declared = parser.getSemanticTable().declareVariable(id.toString(), t, idleft, idright, true);
              
              if (declared) {
                  if (e != null) {
                      boolean compatible = parser.getSemanticTable().checkTypeCompatibility(t, e, idleft);
                      if (compatible) {
                          System.out.println("Variable '" + id + "' declarada e inicializada correctamente como " + t);
                      } else {
                          System.err.println("Error: tipos incompatibles en inicializacion de " + id);
                      }
                  }
              }
              
              parser.updateVariableType(id.toString(), t.toString());
              
              if (parser.codeGenerationEnabled && declared) {
                  parser.getCodeGenerator().declareVariable(id.toString(), t.toString());
                  if (e != null) {
                      String expKey = parser.popCodeKey();
                      String expCode = parser.getCodeValue(expKey);
                      
                      // ✅ SI ESTAMOS EN SWITCH, DIFERIR LA INICIALIZACIÓN
                      if (parser.isInSwitchContext()) {
                          parser.deferSwitchCode(id.toString() + " = " + expCode);
                          System.out.println("DEBUG: Inicialización diferida para switch: " + id + " = " + expCode);
                      } else {
                          // Generar normalmente
                          System.out.println("DEBUG: Inicializando variable " + id + " con " + expCode);
                          parser.getCodeGenerator().generateAssignment(id.toString(), expCode);
                      }
                  }
              }
           :}
           | tipo:t ID:id QUESTION
           {: 
              boolean declared = parser.getSemanticTable().declareVariable(id.toString(), t, idleft, idright, false);
              
              if (declared) {
                  System.out.println("Variable '" + id + "' declarada como " + t + " (sin inicializar)");
              }
              
              parser.updateVariableType(id.toString(), t.toString());
              
              if (parser.codeGenerationEnabled && declared) {
                  parser.getCodeGenerator().declareVariable(id.toString(), t.toString());
              }
           :}
           ;

/* Valores literales con tipos semánticos */
literal ::= LIT_INT:val
          {: 
             RESULT = "INT";  // ✅ Siempre String para semántico
             System.out.println("Literal entero: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("INT", val.toString());
                 parser.pushCodeKey(key);  // Guardar en stack para uso posterior
                 System.out.println("DEBUG: Literal " + val + " guardado con clave " + key);
             }
          :}
         | LIT_FLOAT:val
          {: 
             RESULT = "FLOAT";
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("FLOAT", val.toString());
                 parser.pushCodeKey(key);
             }
          :}
         | LIT_BOOL:val
          {: 
             RESULT = "BOOL";
             System.out.println("Literal booleano detectado: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("BOOL", val.toString());  // ✅ Valor real: "true", "false"
                 parser.pushCodeKey(key);
                 System.out.println("DEBUG: Literal BOOL " + val + " guardado como código");
             }
          :}
         | LIT_CHAR:val
          {: 
             RESULT = "CHAR";
             System.out.println("Literal caracter detectado: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("CHAR", val.toString());  // ✅ Valor real: "'a'", "'x'"
                 parser.pushCodeKey(key);
                 System.out.println("DEBUG: Literal CHAR " + val + " guardado como código");
             }
          :}
         | LIT_STRING:val
          {: 
             RESULT = "STRING";
             System.out.println("Literal cadena detectado: " + val);
             
             if (parser.codeGenerationEnabled) {
                 String key = parser.saveCodeValue("STRING", val.toString());  // ✅ Valor real: "\"hola\""
                 parser.pushCodeKey(key);
                 System.out.println("DEBUG: Literal STRING " + val + " guardado como código");
             }
          :}
         | TRUE 
          {: 
              RESULT = "BOOL";
              if (parser.codeGenerationEnabled) {
                  String key = parser.saveCodeValue("BOOL", "true");
                  parser.pushCodeKey(key);
              }
           :}
         | FALSE 
          {: 
              RESULT = "BOOL";
              if (parser.codeGenerationEnabled) {
                  String key = parser.saveCodeValue("BOOL", "false");
                  parser.pushCodeKey(key);
              }
           :}
         ;

/* Llamadas a funciones con verificación semántica */
llamada_fun ::= ID:id LPAREN arg_list:args RPAREN
              {: 
                 // VALIDACIÓN COMPLETA: Verificar función y argumentos
                 if (parser.getSemanticTable() != null) {
                     // TODO: Extraer tipos reales de arg_list
                     List<String> argTypes = new ArrayList<String>(); // Implementar extracción
                     String returnType = parser.getSemanticTable().checkFunctionCall(
                         id.toString(), argTypes, idleft
                     );
                     
                     if (returnType == null) {
                         RESULT = "ERROR";
                     } else {
                         RESULT = returnType;
                     }
                 } else {
                     RESULT = "ERROR";
                 }

                 if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                    List<String> argTypes = new ArrayList<String>();
                    String code = parser.getCodeGenerator().generateFunctionCall(id.toString(), argTypes);
                 }
              :}
              | ID:id LPAREN RPAREN
              {: 
                 // VALIDACIÓN COMPLETA: Función sin argumentos
                 if (parser.getSemanticTable() != null) {
                     List<String> noArgs = new ArrayList<String>();
                     String returnType = parser.getSemanticTable().checkFunctionCall(
                         id.toString(), noArgs, idleft
                     );
                     
                     if (returnType == null) {
                         RESULT = "ERROR";
                     } else {
                         RESULT = returnType;
                     }
                 } else {
                     RESULT = "ERROR";
                 }
                 if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                    List<String> noArgs = new ArrayList<String>();
                    String code = parser.getCodeGenerator().generateFunctionCall(id.toString(), noArgs);
                }
              :}
              ;

/* Punto de entrada para expresiones con propagación de tipos */
exp ::= exp_log:e {: RESULT = e; :}
      ;

/* Expresiones lógicas con verificación de tipos */
exp_log ::= exp_log:e1 OR term_log:e2
          {: 
             // 1. VALIDACIÓN SEMÁNTICA
             String resultType = parser.getSemanticTable().checkLogicalOperation(
                 e1, e2, "||", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Operación lógica OR requiere operandos booleanos", null);
             } else {
                 RESULT = resultType;  // Debería ser "BOOL"
             }
             
             // 2. GENERACIÓN DE CÓDIGO
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "||", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | term_log:e {: RESULT = e; :}
          ;


term_log ::= term_log:e1 AND factor_log:e2
           {: 
              // 1. VALIDACIÓN SEMÁNTICA
              String resultType = parser.getSemanticTable().checkLogicalOperation(
                  e1, e2, "&&", e1left
              );
              if (resultType == null) {
                  RESULT = "ERROR";
                  parser.report_error("Operación lógica AND requiere operandos booleanos", null);
              } else {
                  RESULT = resultType;
              }
              
              // 2. GENERACIÓN DE CÓDIGO
              if (parser.codeGenerationEnabled && resultType != null) {
                  String rightKey = parser.popCodeKey();
                  String leftKey = parser.popCodeKey();
                  String rightCode = parser.getCodeValue(rightKey);
                  String leftCode = parser.getCodeValue(leftKey);
                  
                  String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "&&", rightCode);
                  String newKey = parser.saveCodeValue(resultType, tempVar);
                  parser.pushCodeKey(newKey);
              }
           :}
           | factor_log:e {: RESULT = e; :}
           ;

factor_log ::= NOT atom_arit:e
             {: 
                // 1. VALIDACIÓN SEMÁNTICA
                String resultType = parser.getSemanticTable().checkLogicalOperation(
                    e, null, "!", eleft
                );
                if (resultType == null) {
                    RESULT = "ERROR";
                    parser.report_error("Operación NOT requiere operando booleano", null);
                } else {
                    RESULT = resultType;
                }
                
                // 2. GENERACIÓN DE CÓDIGO
                if (parser.codeGenerationEnabled && resultType != null) {
                    String operandKey = parser.popCodeKey();
                    String operandCode = parser.getCodeValue(operandKey);
                    
                    String tempVar = parser.getCodeGenerator().generateUnaryOp("!", operandCode);
                    String newKey = parser.saveCodeValue(resultType, tempVar);
                    parser.pushCodeKey(newKey);
                }
             :}
             | exp_rel:e {: RESULT = e; :}
             | LPAREN exp_log:e RPAREN {: RESULT = e; :}
             ;

/* Expresiones relacionales con verificación de tipos */
exp_rel ::= exp_arit:e1 LT exp_arit:e2 
          {: 
             // 1. VALIDACIÓN SEMÁNTICA
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "<", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación <", null);
             } else {
                 RESULT = resultType;  // Debería ser "BOOL"
             }
             
             // 2. GENERACIÓN DE CÓDIGO
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "<", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 LTE exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "<=", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación <=", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "<=", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 GT exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, ">", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación >", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, ">", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 GTE exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, ">=", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación >=", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, ">=", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 EQ exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "==", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación ==", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "==", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e1 NEQ exp_arit:e2 
          {: 
             String resultType = parser.getSemanticTable().checkRelationalOperation(
                 e1, e2, "!=", e1left
             );
             if (resultType == null) {
                 RESULT = "ERROR";
                 parser.report_error("Tipos no comparables en operación !=", null);
             } else {
                 RESULT = resultType;
             }
             
             if (parser.codeGenerationEnabled && resultType != null) {
                 String rightKey = parser.popCodeKey();
                 String leftKey = parser.popCodeKey();
                 String rightCode = parser.getCodeValue(rightKey);
                 String leftCode = parser.getCodeValue(leftKey);
                 
                 String tempVar = parser.getCodeGenerator().generateComparison(leftCode, "!=", rightCode);
                 String newKey = parser.saveCodeValue(resultType, tempVar);
                 parser.pushCodeKey(newKey);
             }
          :}
          | exp_arit:e {: RESULT = e; :}
          ;

/* Expresiones aritméticas con propagación de tipos */
exp_arit ::= exp_arit:e1 PLUS term_arit:e2
           {: 
              // 1. VALIDACIÓN SEMÁNTICA
              String resultType = parser.getSemanticTable().checkArithmeticOperation(
                  e1, e2, "+", e1left
              );
              if (resultType == null) {
                  RESULT = "ERROR";
                  parser.report_error("Tipos incompatibles en operación +", null);
              } else {
                  RESULT = resultType;  // ✅ Tipo semántico
              }
              
              // 2. GENERACIÓN DE CÓDIGO
              if (parser.codeGenerationEnabled && resultType != null) {
                  String rightKey = parser.popCodeKey();  // e2
                  String leftKey = parser.popCodeKey();   // e1
                  String rightCode = parser.getCodeValue(rightKey);
                  String leftCode = parser.getCodeValue(leftKey);
                  
                  String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "+", rightCode);
                  String newKey = parser.saveCodeValue(resultType, tempVar);
                  parser.pushCodeKey(newKey);
              }
           :}
           | exp_arit:e1 MINUS term_arit:e2 
           {: 
              // 1. VALIDACIÓN SEMÁNTICA
              String resultType = parser.getSemanticTable().checkArithmeticOperation(
                  e1, e2, "-", e1left
              );
              if (resultType == null) {
                  RESULT = "ERROR";
                  parser.report_error("Tipos incompatibles en operación -", null);
              } else {
                  RESULT = resultType;
              }
              
              // 2. GENERACIÓN DE CÓDIGO
              if (parser.codeGenerationEnabled && resultType != null) {
                  String rightKey = parser.popCodeKey();
                  String leftKey = parser.popCodeKey();
                  String rightCode = parser.getCodeValue(rightKey);
                  String leftCode = parser.getCodeValue(leftKey);
                  
                  String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "-", rightCode);
                  String newKey = parser.saveCodeValue(resultType, tempVar);
                  parser.pushCodeKey(newKey);
              }
           :}
           | term_arit:e {: RESULT = e; :}
           ;

term_arit ::= term_arit:e1 TIMES factor_arit:e2 
            {: 
               // 1. VALIDACIÓN SEMÁNTICA
               String resultType = parser.getSemanticTable().checkArithmeticOperation(
                   e1, e2, "*", e1left
               );
               if (resultType == null) {
                   RESULT = "ERROR";
                   parser.report_error("Tipos incompatibles en operación *", null);
               } else {
                   RESULT = resultType;
               }
               
               // 2. GENERACIÓN DE CÓDIGO
               if (parser.codeGenerationEnabled && resultType != null) {
                   String rightKey = parser.popCodeKey();
                   String leftKey = parser.popCodeKey();
                   String rightCode = parser.getCodeValue(rightKey);
                   String leftCode = parser.getCodeValue(leftKey);
                   
                   String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "*", rightCode);
                   String newKey = parser.saveCodeValue(resultType, tempVar);
                   parser.pushCodeKey(newKey);
               }
            :}
            | term_arit:e1 DIVIDE factor_arit:e2 
            {: 
               // 1. VALIDACIÓN SEMÁNTICA
               String resultType = parser.getSemanticTable().checkArithmeticOperation(
                   e1, e2, "/", e1left
               );
               if (resultType == null) {
                   RESULT = "ERROR";
                   parser.report_error("Tipos incompatibles en operación /", null);
               } else {
                   RESULT = resultType;
               }
               
               // 2. GENERACIÓN DE CÓDIGO
               if (parser.codeGenerationEnabled && resultType != null) {
                   String rightKey = parser.popCodeKey();
                   String leftKey = parser.popCodeKey();
                   String rightCode = parser.getCodeValue(rightKey);
                   String leftCode = parser.getCodeValue(leftKey);
                   
                   String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "/", rightCode);
                   String newKey = parser.saveCodeValue(resultType, tempVar);
                   parser.pushCodeKey(newKey);
               }
            :}
            | term_arit:e1 MOD factor_arit:e2 
            {: 
               // 1. VALIDACIÓN SEMÁNTICA - MOD solo para enteros
               if (!e1.equals("INT") || !e2.equals("INT")) {
                   parser.report_error("Operador % requiere operandos enteros", null);
                   RESULT = "ERROR";
               } else {
                   RESULT = "INT";
               }
               
               // 2. GENERACIÓN DE CÓDIGO
               if (parser.codeGenerationEnabled && RESULT.equals("INT")) {
                   String rightKey = parser.popCodeKey();
                   String leftKey = parser.popCodeKey();
                   String rightCode = parser.getCodeValue(rightKey);
                   String leftCode = parser.getCodeValue(leftKey);
                   
                   String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "%", rightCode);
                   String newKey = parser.saveCodeValue("INT", tempVar);
                   parser.pushCodeKey(newKey);
               }
            :}
            | factor_arit:e {: RESULT = e; :}
            ;

factor_arit ::= factor_arit:e1 POW power_arit:e2 
              {: 
                 // 1. VALIDACIÓN SEMÁNTICA
                 String resultType = parser.getSemanticTable().checkArithmeticOperation(
                     e1, e2, "**", e1left
                 );
                 if (resultType == null) {
                     RESULT = "ERROR";
                     parser.report_error("Operación POW requiere operandos numéricos", null);
                 } else {
                     // POW inteligente: si ambos son INT, resultado es INT
                     if (e1.equals("INT") && e2.equals("INT")) {
                         RESULT = "INT";
                     } else {
                         RESULT = "FLOAT";
                     }
                 }
                 
                 // 2. GENERACIÓN DE CÓDIGO
                 if (parser.codeGenerationEnabled && resultType != null) {
                     String rightKey = parser.popCodeKey();
                     String leftKey = parser.popCodeKey();
                     String rightCode = parser.getCodeValue(rightKey);
                     String leftCode = parser.getCodeValue(leftKey);
                     
                     String tempVar = parser.getCodeGenerator().generateBinaryOp(leftCode, "**", rightCode);
                     String newKey = parser.saveCodeValue(RESULT, tempVar);
                     parser.pushCodeKey(newKey);
                 }
              :}
              | power_arit:e {: RESULT = e; :}
              ;

power_arit ::= unary_exp:e {: RESULT = e; :}
            ;

/* Operadores unarios con verificación de tipos */
unary_exp ::= MINUS atom_arit:e
            {: 
               // 1. VALIDACIÓN SEMÁNTICA
               if (!e.equals("INT") && !e.equals("FLOAT")) {
                   parser.report_error("Operador unario - requiere operando numérico (INT o FLOAT), encontrado: " + e, null);
                   RESULT = "ERROR";
               } else {
                   RESULT = e;  // Mantiene el tipo original
               }
               
               // 2. GENERACIÓN DE CÓDIGO
               if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                   String operandKey = parser.popCodeKey();
                   String operandCode = parser.getCodeValue(operandKey);
                   
                   String tempVar = parser.getCodeGenerator().generateUnaryOp("-", operandCode);
                   String newKey = parser.saveCodeValue(RESULT, tempVar);
                   parser.pushCodeKey(newKey);
                   
                   System.out.println("DEBUG: Menos unario: -" + operandCode + " = " + tempVar);
               }
            :}
            | INCREMENT ID:id
            {: 
               // 1. VALIDACIÓN SEMÁNTICA
               if (parser.getSemanticTable() != null) {
                   SymbolInfo var = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (var == null) {
                       RESULT = "ERROR";
                   } else if (!var.getTipoVariable().equals("INT") && !var.getTipoVariable().equals("FLOAT")) {
                       parser.report_error("Operador ++ requiere variable numérica", null);
                       RESULT = "ERROR";
                   } else {
                       RESULT = var.getTipoVariable();
                   }
               } else {
                   RESULT = "ERROR";
               }
               
               // 2. GENERACIÓN DE CÓDIGO
               if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                   String tempVar = parser.getCodeGenerator().generateIncrement(id.toString());
                   String newKey = parser.saveCodeValue(RESULT, tempVar);
                   parser.pushCodeKey(newKey);
                   
                   System.out.println("DEBUG: Incremento: ++" + id + " = " + tempVar);
               }
            :}
            | DECREMENT ID:id
            {: 
               // 1. VALIDACIÓN SEMÁNTICA
               if (parser.getSemanticTable() != null) {
                   SymbolInfo var = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (var == null) {
                       RESULT = "ERROR";
                   } else if (!var.getTipoVariable().equals("INT") && !var.getTipoVariable().equals("FLOAT")) {
                       parser.report_error("Operador -- requiere variable numérica", null);
                       RESULT = "ERROR";
                   } else {
                       RESULT = var.getTipoVariable();
                   }
               } else {
                   RESULT = "ERROR";
               }
               
               // 2. GENERACIÓN DE CÓDIGO
               if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                   String tempVar = parser.getCodeGenerator().generateDecrement(id.toString());
                   String newKey = parser.saveCodeValue(RESULT, tempVar);
                   parser.pushCodeKey(newKey);
                   
                   System.out.println("DEBUG: Decremento: --" + id + " = " + tempVar);
               }
            :}
            | atom_arit:e {: RESULT = e; :}
            ;

/* Términos atómicos con tipos semánticos */
atom_arit ::= ID:id
            {: 
               if (parser.getSemanticTable() != null) {
                   SymbolInfo symbol = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (symbol != null) {
                       RESULT = symbol.getTipoVariable();  // ✅ String tipo semántico
                       
                       if (parser.codeGenerationEnabled) {
                           String key = parser.saveCodeValue(RESULT, id.toString());
                           parser.pushCodeKey(key);
                           System.out.println("DEBUG: Variable " + id + " guardada con clave " + key);
                       }
                   } else {
                       RESULT = "ERROR";
                   }
               } else {
                   RESULT = "ERROR";
               }

            :}
            | literal:l {: RESULT = l; :}
            | arr_access:a {: RESULT = a; :}
            | llamada_fun:f {: RESULT = f; :}
            | LPAREN exp:e RPAREN {: RESULT = e; :}
            ;

/* Lista de argumentos */
arg_list ::= exp
           | exp COMMA arg_list
           ;

/* Estructuras de control */
ctrl ::= if_stmt:s
        {:
            RESULT = s;
        :}
       | do_while
       | for_stmt
       | switch_stmt
       ;

/* Estructura if-elif-else con scopes semánticos */
if_stmt ::= IF LPAREN exp:e RPAREN LBLOCK block:then_block RBLOCK
          {: 
             // ✅ TODA LA LÓGICA AL FINAL - SIN ACCIONES INTERMEDIAS
             if (!e.equals("BOOL")) {
                 parser.report_error("Condición de IF debe ser booleana", null);
                 RESULT = "ERROR";
             } else {
                 RESULT = "VOID";
             }
             
             if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                 // Recuperar condición
                 String conditionKey = parser.popCodeKey();
                 String conditionCode = parser.getCodeValue(conditionKey);
                 
                 // Generar etiqueta
                 String endLabel = parser.generateLabel();
                 
                 // ✅ GENERAR CON INSERCIÓN INTELIGENTE
                 parser.getCodeGenerator().generateCompleteIf(conditionCode, endLabel);
                 
                 System.out.println("DEBUG: IF simple - condición: " + conditionCode + " -> " + endLabel);
             }
          :}
          
          | IF LPAREN exp:e RPAREN LBLOCK block:then_block RBLOCK ELSE LBLOCK block:else_block RBLOCK
          {: 
             // ✅ TODA LA LÓGICA AL FINAL - SIN ACCIONES INTERMEDIAS
             if (!e.equals("BOOL")) {
                 parser.report_error("Condición de IF-ELSE debe ser booleana", null);
                 RESULT = "ERROR";
             } else {
                 RESULT = "VOID";
             }
             
             if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                 // Recuperar condición
                 String conditionKey = parser.popCodeKey();
                 String conditionCode = parser.getCodeValue(conditionKey);
                 
                 // Generar etiquetas
                 String elseLabel = parser.generateLabel();
                 String endLabel = parser.generateLabel();
                 
                 // ✅ GENERAR CON INSERCIÓN INTELIGENTE
                 parser.getCodeGenerator().generateCompleteIfElse(conditionCode, elseLabel, endLabel);
                 
                 System.out.println("DEBUG: IF-ELSE - condición: " + conditionCode);
             }
          :}
          ;


/* Estructura do-while con scope semántico*/
do_while ::= DO LBLOCK block:body RBLOCK WHILE LPAREN exp:condition RPAREN QUESTION
          {: 
             // 1. VALIDACIÓN SEMÁNTICA
             if (!condition.equals("BOOL")) {
                 parser.report_error("Condición de DO-WHILE debe ser booleana", null);
                 RESULT = "ERROR";
             } else {
                 RESULT = "VOID";
             }
             
             // 2. GENERACIÓN DE CÓDIGO
             if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                 // Recuperar condición
                 String conditionKey = parser.popCodeKey();
                 String conditionCode = parser.getCodeValue(conditionKey);
                 
                 // Generar etiqueta de inicio
                 String startLabel = parser.generateLabel();
                 
                 // ✅ GENERAR DO-WHILE COMPLETO
                 parser.getCodeGenerator().generateCompleteDoWhile(conditionCode, startLabel);
                 
                 System.out.println("DEBUG: DO-WHILE - condición: " + conditionCode + " -> " + startLabel);
             }
          :}
          ;

/* Estructura for con scope semántico */
for_stmt ::= FOR LPAREN decl_var:init exp:condition QUESTION exp:update RPAREN LBLOCK block:body RBLOCK
          {: 
             // 1. VALIDACIÓN SEMÁNTICA
             if (!condition.equals("BOOL")) {
                 parser.report_error("Condición de FOR debe ser booleana", null);
                 RESULT = "ERROR";
             } else {
                 RESULT = "VOID";
             }
             
             // 2. GENERACIÓN DE CÓDIGO
             if (parser.codeGenerationEnabled && !RESULT.equals("ERROR")) {
                 // Recuperar códigos generados
                 String updateKey = parser.popCodeKey();
                 String updateCode = parser.getCodeValue(updateKey);
                 
                 String conditionKey = parser.popCodeKey();
                 String conditionCode = parser.getCodeValue(conditionKey);
                 
                 // Generar etiquetas
                 String startLabel = parser.generateLabel();
                 String endLabel = parser.generateLabel();
                 
                 // ✅ GENERAR FOR COMPLETO CON TU ESTRUCTURA
                 parser.getCodeGenerator().generateForWithExistingGrammar(conditionCode, updateCode, startLabel, endLabel);
                 
                 System.out.println("DEBUG: FOR - condición: " + conditionCode + ", update: " + updateCode);
             }
          :}
          ;

/* ESTRUCTURA SWITCH ACTUALIZADA */
switch_stmt ::= SWITCH
                {: 
                 // ✅ ENTRAR A MODO SWITCH ANTES DE PROCESAR
                 parser.enterSwitchContext();
                 System.out.println("DEBUG: INICIANDO SWITCH - modo diferido activado");
              :} 
            LPAREN exp:switchExpr RPAREN LBLOCK case_list:cases RBLOCK
              {: 
                 if (parser.codeGenerationEnabled) {
                     // Recuperar la expresión del switch
                     String switchKey = parser.popCodeKey();
                     String switchValue = parser.getCodeValue(switchKey);
                     
                     // Generar etiquetas para el switch
                     String exitLabel = parser.generateLabel();
                     
                     // ✅ GENERAR SWITCH CON CÓDIGO DIFERIDO
                     parser.getCodeGenerator().generateCompleteSwitchWithDeferred(switchValue, exitLabel, parser.getDeferredSwitchCode());
                     
                     System.out.println("DEBUG: SWITCH generado - expr: " + switchValue + " -> " + exitLabel);
                 }
                 
                 // ✅ SALIR DEL MODO SWITCH
                 parser.exitSwitchContext();
              :}
              ;

/* Lista de casos */
case_list ::= case_stmt case_list
           | default_stmt
           | /* vacío */
           ;

/* CASO INDIVIDUAL MEJORADO */
case_stmt ::= CASE exp:caseValue COLON block:caseBlock
            {: 
               if (parser.codeGenerationEnabled) {
                   // Recuperar valor del case
                   String caseKey = parser.popCodeKey();
                   String caseVal = parser.getCodeValue(caseKey);
                   
                   // Generar etiqueta para este case
                   String caseLabel = parser.generateLabel();
                   
                   // ✅ REGISTRAR CASE para el switch
                   parser.getCodeGenerator().registerCase(caseVal, caseLabel);
                   
                   System.out.println("DEBUG: CASE registrado - valor: " + caseVal + " -> " + caseLabel);
               }
            :}
            ;

/* DEFAULT MEJORADO */
default_stmt ::= DEFAULT COLON block:defaultBlock
               {: 
                  if (parser.codeGenerationEnabled) {
                      // Generar etiqueta para default
                      String defaultLabel = parser.generateLabel();
                      
                      // ✅ REGISTRAR DEFAULT
                      parser.getCodeGenerator().registerDefault(defaultLabel);
                      
                      System.out.println("DEBUG: DEFAULT registrado -> " + defaultLabel);
                  }
               :}
               ;

/* BREAK MEJORADO */
break_stmt ::= BREAK QUESTION
             {: 
                if (parser.codeGenerationEnabled) {
                    // ✅ SI ESTAMOS EN SWITCH, DIFERIR EL BREAK
                    if (parser.isInSwitchContext()) {
                        parser.deferSwitchCode("BREAK");
                        System.out.println("DEBUG: Break diferido para switch");
                    } else {
                        parser.getCodeGenerator().generateBreak();
                        System.out.println("DEBUG: Break inmediato (fuera de switch)");
                    }
                }
             :}
             ;

/* Sentencia return con verificación de tipos */
return_stmt ::= RETURN exp:e QUESTION
              {: 
                 System.out.println("DEBUG: Return con expresión, función actual: " + parser.getCurrentFunctionName());
                 
                 if (parser.getSemanticTable() != null && parser.getCurrentFunctionName() != null) {
                     parser.getSemanticTable().checkReturnStatement(parser.getCurrentFunctionName(), e, eleft);
                 } else {
                     System.err.println("ERROR: No se puede verificar return - función actual: " + parser.getCurrentFunctionName());
                 }
                 
                 if (parser.codeGenerationEnabled) {
                     // ✅ RECUPERAR EXPRESIÓN DEL STACK CORRECTAMENTE
                     String expKey = parser.popCodeKey();
                     
                     if (expKey != null) {
                         String expValue = parser.getCodeValue(expKey);
                         parser.getCodeGenerator().generateReturnWithValue(expValue);
                         System.out.println("DEBUG: Return generado con valor: " + expValue + " (clave: " + expKey + ")");
                     } else {
                         // ✅ SI NO HAY CLAVE, USAR LA EXPRESIÓN DIRECTAMENTE
                         parser.getCodeGenerator().generateReturnWithValue(e.toString());
                         System.out.println("DEBUG: Return generado con valor directo: " + e.toString());
                     }
                 }
              :}
              | RETURN:r QUESTION
              {: 
                 System.out.println("DEBUG: Return sin expresión, función actual: " + parser.getCurrentFunctionName());
                 
                 if (parser.getSemanticTable() != null && parser.getCurrentFunctionName() != null) {
                     parser.getSemanticTable().checkReturnStatement(parser.getCurrentFunctionName(), null, rleft);
                 } else {
                     System.err.println("ERROR: No se puede verificar return - función actual: " + parser.getCurrentFunctionName());
                 }
                 
                 if (parser.codeGenerationEnabled) {
                     parser.getCodeGenerator().generateReturnVoid();
                     System.out.println("DEBUG: Return void generado");
                 }
              :}
              | RETURN error QUESTION  {: System.err.println("Error en expresión RETURN. Continuando..."); :}
              ;

// Agrega al final de tu archivo .cup, antes del último ;

/* Funciones de entrada/salida */
read_stmt ::= READ LPAREN ID:id RPAREN QUESTION
            {: 
               // VALIDACIÓN: Verificar que la variable existe
               if (parser.getSemanticTable() != null) {
                   SymbolInfo var = parser.getSemanticTable().checkVariableUsage(id.toString(), idleft);
                   if (var == null) {
                       parser.report_error("Variable '" + id + "' no declarada en READ", null);
                   } else {
                       var.setInicializada(true); // READ inicializa la variable
                   }
               }
               
               if (parser.codeGenerationEnabled) {
                   parser.getCodeGenerator().generateRead(id.toString());
               }
            :}
            | READ LPAREN error RPAREN QUESTION  
            {: 
                parser.report_error("Error en función read - argumento inválido", null); 
            :}
            ;

write_stmt ::= WRITE LPAREN exp:e RPAREN QUESTION
             {: 
                // VALIDACIÓN: Verificar que la expresión sea válida
                if (e != null && e.equals("ERROR")) {
                    parser.report_error("Expresión inválida en write", null);
                }
                
                if (parser.codeGenerationEnabled && !e.equals("ERROR")) {
                    parser.getCodeGenerator().generateWrite(e);
                }
             :}
             | WRITE LPAREN error RPAREN QUESTION  
             {: 
                 parser.report_error("Error en función write - expresión inválida", null); 
             :}
             ;

